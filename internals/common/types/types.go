package types

import (
	"context"
	"encoding/json"
	"fmt"
	"mailflow/internals/email"
	"mailflow/internals/llm"
	"mailflow/internals/rag"
	"strings"
)

// WorkflowContext holds the shared context and resources for the AI agents.
// This allows agents to access necessary services and pass data between them.
type WorkflowContext struct {
	EmailService email.Service
	RAGSystem    *rag.RAGSystem
	LLMGenerator *llm.GeminiGenerator
	// Add other shared resources like database connections, metrics, etc.
}

// EmailCategory represents the categorization of an email.
type EmailCategory string

const (
	ProductEnquiry    EmailCategory = "PRODUCT_ENQUIRY"
	CustomerComplaint EmailCategory = "CUSTOMER_COMPLAINT"
	CustomerFeedback  EmailCategory = "CUSTOMER_FEEDBACK"
	Unrelated         EmailCategory = "UNRELATED"
)

// CategorizeEmailOutput represents the structured output from the email categorization agent.
type CategorizeEmailOutput struct {
	Category EmailCategory `json:"category"`
}

// RAGQueriesOutput represents the structured output of RAG queries.
type RAGQueriesOutput struct {
	Queries []string `json:"queries"`
}

// WriterOutput represents the structured output of the email writer agent.
type WriterOutput struct {
	Email string `json:"email_content"`
}

// ProofReaderOutput represents the structured output of the email proofreader agent.
type ProofReaderOutput struct {
	Feedback string `json:"feedback"`
	Send     bool   `json:"send"`
}

// Task represents a unit of work that an Agent can perform.
// In Mailflow, this could be an incoming email to process.
// This combines the original `GraphState` with `Task`.
type Task struct {
	ID                 string            // Unique ID for the task
	EmailInfo          email.EmailInfo   // The email associated with this task
	EmailsInfo         []email.EmailInfo // List of emails to process (remaining in inbox for next iteration)
	CurrentEmailInfo   email.EmailInfo   // The email info currently being processed
	EmailCategory      string            // Category assigned to the current email
	GeneratedEmail     string            // The draft email generated by the writer agent
	RAGQueries         []string          // Queries generated for RAG retrieval
	RetrievedDocuments string            // Concatenated documents retrieved from RAG
	WriterMessages     []string          // History of writer's drafts and proofreader feedback
	Sendable           bool              // Indicates if the generated email is sendable
	Trials             int               // Number of attempts to generate a sendable email
	CurrentState       string            // e.g., "categorizing", "generating_response", "qa_review"
	Result             interface{}       // Stores the result of the last agent's operation
	Error              error             // Stores any error encountered during task processing
}

// NewTask creates a new initial task.
func NewTask(emailInfo email.EmailInfo, allEmails []email.EmailInfo) Task {
	return Task{
		ID:                 fmt.Sprintf("email-task-%s", emailInfo.ID),
		EmailInfo:          emailInfo,
		EmailsInfo:         allEmails,
		CurrentEmailInfo:   emailInfo, // Initialize with the current email
		CurrentState:       "received",
		WriterMessages:     []string{},
		RAGQueries:         []string{},
		RetrievedDocuments: "",
		Sendable:           false,
		Trials:             0,
	}
}

// Agent defines the interface for an AI agent.
// Each agent takes a context and a task, processes it, and returns an updated task or an error.
type Agent interface {
	Name() string // Returns the name of the agent (e.g., "EmailCategorizer")
	Process(ctx context.Context, task Task, wfCtx *WorkflowContext) (Task, error)
}

// Tool defines an interface for external functionalities that agents can use.
// This is a generic interface; specific tools (like GmailTool, RAGTool) will implement it.
type Tool interface {
	Name() string // Returns the name of the tool (e.g., "GmailSender", "RAGRetriever")
	Execute(ctx context.Context, input interface{}) (interface{}, error)
}

// JSONResponseParser is a helper to parse JSON responses from LLMs.
type JSONResponseParser struct{}

// NewJSONResponseParser creates a new JSONResponseParser.
func NewJSONResponseParser() *JSONResponseParser {
	return &JSONResponseParser{}
}

// Parse extracts and cleans JSON from an LLM string response.
func (p *JSONResponseParser) Parse(rawLLMResponse string) (string, error) {
	cleanedResponse := strings.TrimSpace(rawLLMResponse)
	cleanedResponse = strings.TrimPrefix(cleanedResponse, "```json")
	cleanedResponse = strings.TrimSuffix(cleanedResponse, "```")
	cleanedResponse = strings.TrimSpace(cleanedResponse)
	return cleanedResponse, nil
}

// TextResponseParser is a helper to parse plain text responses from LLMs.
type TextResponseParser struct{}

// NewTextResponseParser creates a new TextResponseParser.
func NewTextResponseParser() *TextResponseParser {
	return &TextResponseParser{}
}

// Parse extracts plain text from an LLM string response.
func (p *TextResponseParser) Parse(rawLLMResponse string) (string, error) {
	return strings.TrimSpace(rawLLMResponse), nil
}

// CallLLMWithStructuredOutput is a helper function to call the LLM and parse a structured JSON output.
func CallLLMWithStructuredOutput[T any](ctx context.Context, generator *llm.GeminiGenerator, prompt string, parser *JSONResponseParser) (*T, error) {
	rawResponse, err := generator.GenerateContent(ctx, prompt, nil) // No specific generation config for now
	if err != nil {
		return nil, fmt.Errorf("failed to generate LLM content for structured output: %w", err)
	}

	cleanedResponse, err := parser.Parse(rawResponse)
	if err != nil {
		return nil, fmt.Errorf("failed to parse LLM response: %w", err)
	}

	var output T
	err = json.Unmarshal([]byte(cleanedResponse), &output)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal LLM response to struct: %w. Cleaned Response: %s", err, cleanedResponse)
	}

	return &output, nil
}

// CallLLMForTextOutput is a helper function to call the LLM and parse a plain text output.
func CallLLMForTextOutput(ctx context.Context, generator *llm.GeminiGenerator, prompt string, parser *TextResponseParser) (string, error) {
	textOutput, err := generator.GenerateContent(ctx, prompt, nil) // No specific generation config for now
	if err != nil {
		return "", fmt.Errorf("failed to generate LLM content for text output: %w", err)
	}

	cleanedOutput, err := parser.Parse(textOutput)
	if err != nil {
		return "", fmt.Errorf("failed to parse LLM response: %w", err)
	}
	return cleanedOutput, nil
}
